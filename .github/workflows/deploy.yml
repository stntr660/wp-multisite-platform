name: üöÄ Deploy WordPress Multi-Site

on:
  push:
    branches:
      - main
      - staging
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, closed]

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # ===========================================
  # Security and Quality Checks
  # ===========================================
  security-scan:
    name: üîí Security & Quality Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check for sensitive files
        run: |
          echo "üîç Checking for sensitive files and credentials..."
          
          # Check for accidentally committed secrets
          if find . -name "*.sql" -not -path "./mysql/init/*" | head -5; then
            echo "‚ùå Found .sql files outside of mysql/init directory"
            exit 1
          fi
          
          if find . -name ".env" | grep -v ".env.example"; then
            echo "‚ùå Found .env files - these should not be committed"
            exit 1
          fi
          
          # Check for private keys
          if find . -name "*.pem" -o -name "id_rsa*"; then
            echo "‚ùå Found private key files"
            exit 1
          fi
          
          echo "‚úÖ Security check passed"

      - name: Lint Docker files
        run: |
          echo "üê≥ Linting Docker files..."
          
          # Install hadolint
          wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          chmod +x hadolint
          
          # Lint all Dockerfiles
          for dockerfile in $(find . -name "Dockerfile*"); do
            echo "Linting $dockerfile..."
            ./hadolint "$dockerfile"
          done
          
          echo "‚úÖ Docker lint passed"

      - name: Validate Docker Compose
        run: |
          echo "üìã Validating Docker Compose..."
          docker-compose config
          echo "‚úÖ Docker Compose validation passed"

  # ===========================================
  # Build and Test
  # ===========================================
  build-test:
    name: üî® Build & Test
    runs-on: ubuntu-latest
    needs: security-scan
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create test environment file
        run: |
          cat > .env << EOF
          # Test Environment Configuration
          MYSQL_ROOT_PASSWORD=test_root_password
          
          # Database configurations for each site
          AIRAROM_DB_NAME=test_airarom_wp
          AIRAROM_DB_USER=test_airarom
          AIRAROM_DB_PASSWORD=test_airarom_pass
          
          ELECTROROMANOS_DB_NAME=test_electroromanos_wp
          ELECTROROMANOS_DB_USER=test_electroromanos
          ELECTROROMANOS_DB_PASSWORD=test_electroromanos_pass
          
          FRESHEXPRESS_DB_NAME=test_freshexpress_wp
          FRESHEXPRESS_DB_USER=test_freshexpress
          FRESHEXPRESS_DB_PASSWORD=test_freshexpress_pass
          
          SABEEL_DB_NAME=test_sabeel_wp
          SABEEL_DB_USER=test_sabeel
          SABEEL_DB_PASSWORD=test_sabeel_pass
          
          SABEELACADEMY_DB_NAME=test_sabeelacademy_wp
          SABEELACADEMY_DB_USER=test_sabeelacademy
          SABEELACADEMY_DB_PASSWORD=test_sabeelacademy_pass
          
          SUMO_DB_NAME=test_sumo_wp
          SUMO_DB_USER=test_sumo
          SUMO_DB_PASSWORD=test_sumo_pass
          
          YVESMOREL_DB_NAME=test_yvesmorel_wp
          YVESMOREL_DB_USER=test_yvesmorel
          YVESMOREL_DB_PASSWORD=test_yvesmorel_pass
          
          ZONEMATION_DB_NAME=test_zonemation_wp
          ZONEMATION_DB_USER=test_zonemation
          ZONEMATION_DB_PASSWORD=test_zonemation_pass
          EOF

      - name: Build Docker images
        run: |
          echo "üî® Building WordPress Docker image..."
          docker-compose build wordpress-base
          
          echo "üî® Building all services..."
          docker-compose build

      - name: Start test environment
        run: |
          echo "üöÄ Starting test environment..."
          docker-compose up -d mysql redis
          
          # Wait for MySQL to be ready
          echo "‚è≥ Waiting for MySQL to be ready..."
          timeout 60 bash -c 'until docker-compose exec -T mysql mysqladmin ping -h localhost --silent; do sleep 2; done'
          
          echo "‚úÖ Test environment started"

      - name: Run health checks
        run: |
          echo "üè• Running health checks..."
          
          # Check MySQL connectivity
          docker-compose exec -T mysql mysql -uroot -ptest_root_password -e "SHOW DATABASES;"
          
          # Check Redis connectivity
          docker-compose exec -T redis redis-cli ping
          
          echo "‚úÖ Health checks passed"

      - name: Cleanup test environment
        if: always()
        run: |
          echo "üßπ Cleaning up test environment..."
          docker-compose down -v
          docker system prune -f

  # ===========================================
  # Deploy to Staging
  # ===========================================
  deploy-staging:
    name: üö¶ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [security-scan, build-test]
    if: github.ref == 'refs/heads/staging'
    environment:
      name: staging
      url: https://staging.zonemation.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to staging server
        run: |
          echo "üöÄ Deploying to staging server..."
          
          # Sync code to staging server
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='logs' \
            --exclude='backups' \
            ./ ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:${{ secrets.STAGING_PATH }}/
          
          # Run deployment on staging server
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} "
            cd ${{ secrets.STAGING_PATH }}
            
            # Create environment file
            cat > .env << 'EOF'
          ${{ secrets.STAGING_ENV }}
          EOF
            
            # Run deployment script
            chmod +x scripts/deploy.sh
            ./scripts/deploy.sh restart
          "
          
          echo "‚úÖ Staging deployment completed"

      - name: Run staging health checks
        run: |
          echo "üè• Running staging health checks..."
          
          # Wait for services to be ready
          sleep 30
          
          # Check if staging sites are responding
          for site in "airarom" "electroromanos" "freshexpress" "sabeel" "sabeelacademy" "sumo" "yvesmorel" "zonemation"; do
            echo "Checking $site staging site..."
            curl -f -L "https://staging-$site.zonemation.com" || echo "Warning: $site staging site not responding"
          done
          
          echo "‚úÖ Staging health checks completed"

  # ===========================================
  # Deploy to Production
  # ===========================================
  deploy-production:
    name: üåü Deploy to Production
    runs-on: ubuntu-latest
    needs: [security-scan, build-test]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://zonemation.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Pre-deployment backup
        run: |
          echo "üíæ Creating pre-deployment backup..."
          
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd ${{ secrets.PRODUCTION_PATH }}
            
            # Create backup before deployment
            ./scripts/deploy.sh backup
          "
          
          echo "‚úÖ Backup completed"

      - name: Deploy to production server
        run: |
          echo "üöÄ Deploying to production server..."
          
          # Sync code to production server
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='logs' \
            --exclude='backups' \
            --exclude='*.log' \
            ./ ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:${{ secrets.PRODUCTION_PATH }}/
          
          # Run deployment on production server
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd ${{ secrets.PRODUCTION_PATH }}
            
            # Create environment file
            cat > .env << 'EOF'
          ${{ secrets.PRODUCTION_ENV }}
          EOF
            
            # Run deployment script with zero-downtime strategy
            chmod +x scripts/deploy.sh
            ./scripts/deploy.sh update
          "
          
          echo "‚úÖ Production deployment completed"

      - name: Run production health checks
        run: |
          echo "üè• Running production health checks..."
          
          # Wait for services to be ready
          sleep 60
          
          # Check if production sites are responding
          sites=("airarom.ma" "electroromanos.ma" "freshexpress.ma" "sabeel.agency" "sabeelacademy.ma" "sumo.ma" "yvesmorel.ma" "zonemation.com" "oumniarentalcars.com")
          
          for site in "${sites[@]}"; do
            echo "Checking $site..."
            if curl -f -L --max-time 30 "https://$site"; then
              echo "‚úÖ $site is responding"
            else
              echo "‚ùå $site is not responding"
              exit 1
            fi
          done
          
          echo "‚úÖ All production health checks passed"

      - name: Post-deployment monitoring
        run: |
          echo "üìä Setting up post-deployment monitoring..."
          
          # Send deployment notification
          curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
            -H 'Content-type: application/json' \
            --data "{
              \"text\": \"üéâ WordPress Multi-Site deployment to production completed successfully!\",
              \"attachments\": [{
                \"color\": \"good\",
                \"fields\": [{
                  \"title\": \"Deployment\",
                  \"value\": \"Production deployment completed\",
                  \"short\": true
                }, {
                  \"title\": \"Commit\",
                  \"value\": \"${{ github.sha }}\",
                  \"short\": true
                }, {
                  \"title\": \"Branch\",
                  \"value\": \"${{ github.ref }}\",
                  \"short\": true
                }]
              }]
            }" || echo "Slack notification failed"

  # ===========================================
  # Cleanup PR Environment
  # ===========================================
  cleanup-pr:
    name: üßπ Cleanup PR Environment
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    
    steps:
      - name: Cleanup PR environment
        run: |
          echo "üßπ Cleaning up PR environment..."
          # Add any PR-specific cleanup logic here
          echo "‚úÖ Cleanup completed"

  # ===========================================
  # Rollback Capability
  # ===========================================
  rollback:
    name: ‚Ü©Ô∏è Rollback Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment:
      name: production
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback deployment
        run: |
          echo "‚Ü©Ô∏è Rolling back deployment..."
          
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd ${{ secrets.PRODUCTION_PATH }}
            
            # Find latest backup
            LATEST_BACKUP=\$(ls -t backups/ | head -n 1)
            
            if [ -n \"\$LATEST_BACKUP\" ]; then
              echo \"Rolling back to: \$LATEST_BACKUP\"
              
              # Stop services
              ./scripts/deploy.sh stop
              
              # Restore from backup
              # This would include database and file restoration
              echo \"Restoring from backup: \$LATEST_BACKUP\"
              
              # Start services
              ./scripts/deploy.sh start
              
              echo \"‚úÖ Rollback completed\"
            else
              echo \"‚ùå No backup found for rollback\"
              exit 1
            fi
          "